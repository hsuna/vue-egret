(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{494:function(e,n,t){"use strict";t.r(n);var r={name:"component-doc",data:function(){return{}}},a=t(49),l=Object(a.a)(r,(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"渲染函数-jsx"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#渲染函数-jsx"}},[e._v("#")]),e._v(" 渲染函数 & JSX")]),e._v(" "),t("h2",{attrs:{id:"基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[e._v("#")]),e._v(" 基础")]),e._v(" "),t("p",[e._v("VueEgret 推荐在绝大多数情况下使用模板来创建你的 Egret。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力。这时你可以用渲染函数，它比模板更接近编译器。")]),e._v(" "),t("p",[e._v("让我们深入一个简单的例子，这个例子里 "),t("code",[e._v("render")]),e._v(" 函数很实用。假设我们要生成一些带锚点的标题：")]),e._v(" "),t("h1",[t("a",{attrs:{name:"hello-world",href:"#hello-world"}},[e._v("\n    Hello world!\n  ")])]),e._v("\n对于上面的 HTML，你决定这样定义组件接口：\n"),t("anchored-heading",{attrs:{level:1}},[e._v("Hello world!")]),e._v(" "),t("p",[e._v("当开始写一个只能通过 level prop 动态生成标题 (heading) 的组件时，你可能很快想到这样实现：")]),e._v(" "),t("p",[e._v("Vue.component('anchored-heading', {\ntemplate: '#anchored-heading-template',\nprops: {\nlevel: {\ntype: Number,\nrequired: true\n}\n}\n})\n这里用模板并不是最好的选择：不但代码冗长，而且在每一个级别的标题中重复书写了 "),e._t("default"),e._v("，在要插入锚点元素时还要再次重复。")],2),e._v(" "),t("p",[e._v("虽然模板在大多数组件中都非常好用，但是显然在这里它就不合适了。那么，我们来尝试使用 render 函数重写上面的例子：")]),e._v(" "),t("p",[e._v("Vue.component('anchored-heading', {\nrender: function (createElement) {\nreturn createElement(\n'h' + this.level,   // 标签名称\nthis.$slots.default // 子节点数组\n)\n},\nprops: {\nlevel: {\ntype: Number,\nrequired: true\n}\n}\n})\n看起来简单多了！这样代码精简很多，但是需要非常熟悉 Vue 的实例 property。在这个例子中，你需要知道，向组件中传递不带 v-slot 指令的子节点时，比如 anchored-heading 中的 Hello world!，这些子节点被存储在组件实例中的 $slots.default 中。如果你还不了解，在深入渲染函数之前推荐阅读实例 property API。")])],1)}),[],!1,null,null,null);n.default=l.exports}}]);